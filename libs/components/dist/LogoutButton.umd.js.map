{"version":3,"file":"LogoutButton.umd.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;ACVa;AACb,6BAA6C,EAAE,aAAa,CAAC;AAC7D;AACA;AACA,SAAe;AACf;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;;;;;;;;;;;;ACAA;AACA;;AAEA;AACA;AACA,MAAM,KAAuC,EAAE,yBAQ5C;;AAEH;AACA;AACA,IAAI,qBAAuB;AAC3B;AACA;;AAEA;AACA,kDAAe,IAAI;;;;;ACtBoO;AAEvP,MAAM,UAAU,GAAG,aCEX,sCAiBM;IAhBJ,KAAK,EAAC,4BAA4B;IAClC,KAAK,EAAC,IAAI;IACV,MAAM,EAAC,IAAI;IACX,IAAI,EAAC,MAAM;IACX,OAAO,EAAC,WAAW;CDD5B,EAAE;IACD,aCEQ,sCAIE;QAHA,IAAI,EAAC,SAAS;QACd,cAAY,EAAC,IAAI;QACjB,CAAC,EAAC,8BAA8B;KDDzC,CAAC;IACF,aCEQ,sCAGE;QAFA,IAAI,EAAC,SAAS;QACd,CAAC,EAAC,6CAA6C;KDDxD,CAAC;IACF,aCEQ,sCAA8D;QAAxD,IAAI,EAAC,SAAS;QAAC,cAAY,EAAC,IAAI;QAAC,CAAC,EAAC,kBAAkB;KDElE,CAAC;CACH,EAAE,CAAC,CAAC,CAAC;AAEC,SAAS,MAAM,CAAC,IAAS,EAAC,MAAW,EAAC,MAAW,EAAC,MAAW,EAAC,KAAU,EAAC,QAAa;IAC3F,MAAM,iBAAiB,GAAG,kCAAiB,CAAC,QAAQ,CAAE;IAEtD,OAAO,CAAC,2BAAU,EAAE,EC3BpB,qCAuBM;QAvBD,KAAK,EAAC,eAAe;QAAE,OAAK,yCAAEA,IAAAA,CAAAA,OAAO,CAAC,MAAM;KD8BhD,EAAE;QC7BD,6BAqBO,4BArBP,GAqBO;YApBL,8BAmBS,qBAnBD,KAAK,EAAC,qCAAqC;gBAHzD,mCAIQ,GAiBM;oBAjBN,UAiBM;iBDeL,CAAC;gBCpCV;aDsCO,CAAC;SACH,CAAC;KACH,CAAC,CAAC;AACL,CAAC;;;;;AGzCD;AACO;;;ACDmB;AAC1B,sBAAsB,qBAAG;AACzB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/E0B;AAC1B,4BAA4B,qBAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA,MAAM,cAAG;AACT;AACA;AACA;AACA,MAAM,cAAG;AACT;AACA;AACA,MAAM,aAAE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,eAAI;AACV;AACA;AACA;AACA;AACA;AACA,MAAM,kBAAO;AACb;AACA;AACA;AACA;AACA;;;ACvC8C;AAClB;AACnC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,uBAAuB,WAAW;AAClC;AACA,wBAAwB,WAAW;AACnC;AACA,uBAAuB,WAAW,MAAM,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA,4CAA4C,uGAAuG;AACnJ,6BAA6B;AAC7B;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,4CAA4C,uGAAuG;AACnJ,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,kDAAkD;AACvE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF,sEAAsE;AACtE;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;AAC7G,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACvM0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAK;AAChB;AACA;AACA;AACA,KAAK;AACL;AAC4C;;;ACzBlB;AACgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4BAAS;AAC1C;AACA;AACA,2BAA2B,sBAAO;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,eAAK;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AAC8B;;;AC/CJ;AAC4D;AAC/C;AACmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAS,IAAI,IAAI;AACzD;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iCAAiC;AAC1D;AACA,sBAAsB,UAAU;AAChC;AACA,2BAA2B,oBAAoB;AAC/C,kBAAkB,WAAW;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAe;AAC1C;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;;;ACjIY;AAClC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4BAAS;AAC1C;AACA;AACA,2BAA2B,sBAAO;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,eAAK;AAChB;AACA;AACA;AACA,oCAAoC,QAAQ,UAAU,GAAG,cAAc,GAAG;AAC1E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACuB;;;AC7D8B;AAC3B;AAC2D;AACnC;AAC3C,MAAM,eAAO;AACpB;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAAS;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,4BAAS;AAC9C,mBAAmB,sBAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB,IAAI,gBAAgB,EAAE,oBAAoB;AAC1F;AACA;AACA;AACA;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA,eAAe,eAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFqC;AACF;AACA;AAC2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB,eAAe,gBAAgB,OAAO,oBAAoB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,uBAAS;AAC/B,sBAAsB,kBAAK;AAC3B,uBAAuB,mBAAM;AAC7B;AACA;AACA,KAAK,GAAG,KAAK,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,yBAAW;AACjC;AACA;AACA,sBAAsB,eAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAA2C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,4BAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,sBAAsB,GAAG;AAC3C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,yBAAW;AACtB;AACA,uBAAuB,uBAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,IAAI,OAAO;AACjF;AACA;AACA;AACA,sCAAsC,oBAAoB,yDAAyD,uDAAuD;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA,KAAK,kBAAkB,oBAAoB,yDAAyD,uDAAuD;AAC3J;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;ACjWuC;AACuB;AACW;AAClE;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrEmC;AACF;AACG;AACC;AACmB;;;ACJJ;AAC7C,gCAAgC,eAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB,IAAI,kBAAkB,EAAE,sBAAsB,qBAAqB,oBAAoB,IAAI,gBAAgB,EAAE,oBAAoB;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChC+B;AACyB;AACxD,gBAAgB,0BAAQ,KAAK,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,+BAAe;AAC5B;AACA;AACA;AACA;AACA;;;ACtBiC;AACmB;AACyD;AAClF;AAC3B,QAAQ,OAAO,4BAAG,EAAE,+BAAe;AACnC,MAAM,oBAAI,GAAG,qBAAG;AAChB,YAAY,qBAAG;AACf,cAAc,qBAAG;AACjB,gBAAgB,qBAAG;AACnB,kBAAkB,qBAAG;AACrB,oBAAoB,qBAAG;AACvB,iBAAiB,qBAAG;AACpB,kBAAkB,qBAAG;AACrB,uBAAK,OAAO,uBAAO;AACnB,kBAAkB,uBAAO;AACzB,oBAAoB,kBAAK;AACzB,QAAQ,uBAAO;AACf,sBAAsB,yBAAW;AACjC;AACA,gCAAgC,uBAAS;AACzC;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA,oCAAoC,KAAK;AACzC,IAAI,oBAAI;AACR,oCAAoC,cAAG;AACvC;AACA,oCAAoC,KAAK;AACzC;AACA,oCAAoC,kBAAO;AAC3C;AACA,oCAAoC,kBAAO;AAC3C;AACA,oCAAoC,GAAG;AACvC;AACA;AACA,2BAA2B,kBAAK;AAChC,yBAAyB,yBAAW;AACpC;AACA,gCAAgC,uBAAS;AACzC;AACA,8DAA8D,GAAG;AACjE;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA,YAAY,uBAAO;AACnB;AACA,wDAAwD,KAAK;AAC7D,YAAY,oBAAI,oBAAoB,0CAA0C;AAC9E,wDAAwD,cAAG;AAC3D;AACA,wDAAwD,KAAK;AAC7D;AACA,wDAAwD,kBAAO;AAC/D;AACA,wDAAwD,kBAAO;AAC/D;AACA;AACA;AACA,CAAC;AACM,MAAM,+BAAe;AAC5B;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1EuG;AACvB;AAC5B;AACpD,QAAQ,mBAAmB,sDAAiB,oCAAG,EAAE,6BAA6B;AAC9E,QAAQ,OAAO,4BAAG,EAAE,+BAAe;AACnC;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA,gBAAgB,uBAAO,OAAO;AAC9B,iBAAiB,IAAI;AACrB,qBAAqB,iBAAiB;AACtC;AACA;AACA,yBAAyB,kBAAkB;AAC3C,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA,gBAAgB,uBAAO,OAAO;AAC9B;AACA;AACA,wBAAwB,uBAAO,OAAO;AACtC,yBAAyB,IAAI;AAC7B,6BAA6B,iBAAiB;AAC9C;AACA;AACA,iCAAiC,kBAAkB;AACnD,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,sBAAsB,+BAAe;AACrC;AACA;AACA,kDAAkD,uBAAO;AACzD;AACA;AACA,YAAY,QAAQ;AACpB,0BAA0B,mCAAmB;AAC7C;AACA;AACA,oDAAoD,uBAAO;AAC3D;AACO;AACP;AACA;AACA;AACA;AACA;;;ACxEoD;AACA;AACrB;AACxB;AACP,YAAY,UAAU;AACtB,YAAY,WAAW;AACvB;AACA;AACA,KAAK;AACL,aAAa;AACb;;;ACV+B;AACqB;AACP;AAC7C;AACsC;AACA;AACtC;AACsC;AACI;AACN;AACwB;;;ApBkBvB;AAC4B;AAEjE,wEAAe,iCAAe,CAAC;IAC7B,IAAI,EAAE,aAAa;IACnB,KAAK;QACH,MAAM,EAAE,OAAM,EAAE,GAAI,+BAAe,EAAE;QACrC,OAAO,EAAE,OAAM,EAAG;IACpB,CAAC;CACF,CAAC;;;AqBrCyP;;;;ACA1K;AAClB;AACL;;AAE1D,CAAmF;AACnF,iCAAiC,+BAAe,CAAC,mCAAM,aAAa,MAAM;;AAE1E,iDAAe;;ACPS;AACA;AACxB,8CAAe,YAAG;AACI","sources":["webpack://LogoutButton/webpack/universalModuleDefinition","webpack://LogoutButton/../../node_modules/vue-loader/dist/exportHelper.js","webpack://LogoutButton/external umd \"axios\"","webpack://LogoutButton/external umd \"jose\"","webpack://LogoutButton/external umd \"n3\"","webpack://LogoutButton/external umd \"vue\"","webpack://LogoutButton/webpack/bootstrap","webpack://LogoutButton/webpack/runtime/define property getters","webpack://LogoutButton/webpack/runtime/hasOwnProperty shorthand","webpack://LogoutButton/webpack/runtime/publicPath","webpack://LogoutButton/../../node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js","webpack://LogoutButton/./src/LogoutButton.vue?76ab","webpack://LogoutButton/./src/LogoutButton.vue","webpack://LogoutButton/./src/LogoutButton.vue?0cf3","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/useCache.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/useServiceWorkerNotifications.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/useServiceWorkerUpdate.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/namespaces.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/n3Extensions.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/solid-oidc-client-browser/requestDynamicClientRegistration.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/solid-oidc-client-browser/requestAccessToken.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/solid-oidc-client-browser/AuthorizationCodeGrantFlow.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/solid-oidc-client-browser/RefreshTokenGrant.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/solid-oidc-client-browser/Session.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/solidRequests.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/src/interopRequest.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/solid/dist/esm/index.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/rdpCapableSession.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/useSolidSession.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/useSolidProfile.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/useSolidWebPush.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/src/useIsLoggedIn.js","webpack://LogoutButton/../../node_modules/hackathon-demo/libs/composables/dist/esm/index.js","webpack://LogoutButton/./src/LogoutButton.vue?392f","webpack://LogoutButton/./src/LogoutButton.vue?12b8","webpack://LogoutButton/../../node_modules/@vue/cli-service/lib/commands/build/entry-lib.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue\"), require(\"n3\"), require(\"axios\"), require(\"jose\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vue\", \"n3\", \"axios\", \"jose\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"LogoutButton\"] = factory(require(\"vue\"), require(\"n3\"), require(\"axios\"), require(\"jose\"));\n\telse\n\t\troot[\"LogoutButton\"] = factory(root[\"vue\"], root[\"n3\"], root[\"axios\"], root[\"jose\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__380__, __WEBPACK_EXTERNAL_MODULE__907__, __WEBPACK_EXTERNAL_MODULE__742__, __WEBPACK_EXTERNAL_MODULE__603__) {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.default = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__742__;","module.exports = __WEBPACK_EXTERNAL_MODULE__603__;","module.exports = __WEBPACK_EXTERNAL_MODULE__907__;","module.exports = __WEBPACK_EXTERNAL_MODULE__380__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"\";","/* eslint-disable no-var */\n// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var currentScript = window.document.currentScript\n  if (process.env.NEED_CURRENTSCRIPT_POLYFILL) {\n    var getCurrentScript = require('@soda/get-current-script')\n    currentScript = getCurrentScript()\n\n    // for backward compatibility, because previously we directly included the polyfill\n    if (!('currentScript' in document)) {\n      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })\n    }\n  }\n\n  var src = currentScript && currentScript.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/)\n  if (src) {\n    __webpack_public_path__ = src[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\nexport default null\n","import { renderSlot as _renderSlot, createElementVNode as _createElementVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode(\"svg\", {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: \"20\",\n  height: \"20\",\n  fill: \"none\",\n  viewBox: \"0 0 20 20\"\n}, [\n  /*#__PURE__*/_createElementVNode(\"path\", {\n    fill: \"#003D66\",\n    \"fill-opacity\": \".9\",\n    d: \"M13 5v3H5v4h8v3l5.25-5L13 5Z\"\n  }),\n  /*#__PURE__*/_createElementVNode(\"path\", {\n    fill: \"#61C7F2\",\n    d: \"M14 7.333 16.8 10 14 12.667V11H6V9h8V7.333Z\"\n  }),\n  /*#__PURE__*/_createElementVNode(\"path\", {\n    fill: \"#3B3B3B\",\n    \"fill-opacity\": \".9\",\n    d: \"M2 3V1H1v18h1V3Z\"\n  })\n], -1)\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _component_Button = _resolveComponent(\"Button\")!\n\n  return (_openBlock(), _createElementBlock(\"div\", {\n    class: \"logout-button\",\n    onClick: _cache[0] || (_cache[0] = ($event: any) => (_ctx.session.logout()))\n  }, [\n    _renderSlot(_ctx.$slots, \"default\", {}, () => [\n      _createVNode(_component_Button, { class: \"p-button-text p-button-rounded ml-1\" }, {\n        default: _withCtx(() => [\n          _hoisted_1\n        ]),\n        _: 1\n      })\n    ])\n  ]))\n}","<template>\n  <div class=\"logout-button\" @click=\"session.logout()\">\n    <slot>\n      <Button class=\"p-button-text p-button-rounded ml-1\">\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          width=\"20\"\n          height=\"20\"\n          fill=\"none\"\n          viewBox=\"0 0 20 20\"\n        >\n          <path\n            fill=\"#003D66\"\n            fill-opacity=\".9\"\n            d=\"M13 5v3H5v4h8v3l5.25-5L13 5Z\"\n          />\n          <path\n            fill=\"#61C7F2\"\n            d=\"M14 7.333 16.8 10 14 12.667V11H6V9h8V7.333Z\"\n          />\n          <path fill=\"#3B3B3B\" fill-opacity=\".9\" d=\"M2 3V1H1v18h1V3Z\" />\n        </svg>\n      </Button>\n    </slot>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\nimport { useSolidSession } from \"hackathon-demo/libs/composables\";\n\nexport default defineComponent({\n  name: \"LoginButton\",\n  setup() {\n    const { session } = useSolidSession();\n    return { session };\n  },\n});\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped lang=\"scss\"></style>\n","export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/ts-loader/index.js??clonedRuleSet-83.use[1]!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./LogoutButton.vue?vue&type=template&id=79d8ba55&ts=true\"","const cache = {};\nexport const useCache = () => cache;\n","import { ref } from \"vue\";\nconst hasActivePush = ref(false);\n/** ask the user for permission to display notifications */\nexport const askForNotificationPermission = async () => {\n    const status = await Notification.requestPermission();\n    console.log(\"### PWA  \\t| Notification permission status:\", status);\n    return status;\n};\n/**\n * We should perform this check whenever the user accesses our app\n * because subscription objects may change during their lifetime.\n * We need to make sure that it is synchronized with our server.\n * If there is no subscription object we can update our UI\n * to ask the user if they would like receive notifications.\n */\nconst _checkSubscription = async () => {\n    if (!(\"serviceWorker\" in navigator)) {\n        throw new Error(\"Service Worker not in Navigator\");\n    }\n    const reg = await navigator.serviceWorker.ready;\n    const sub = await reg?.pushManager.getSubscription();\n    if (!sub) {\n        throw new Error(`No Subscription`); // Update UI to ask user to register for Push\n    }\n    return sub; // We have a subscription, update the database\n};\n// Notification.permission == \"granted\" && await _checkSubscription()\nconst _hasActivePush = async () => {\n    return Notification.permission == \"granted\" && await _checkSubscription().then(() => true).catch(() => false);\n};\n_hasActivePush().then(hasPush => hasActivePush.value = hasPush);\n/** It's best practice to call the ``subscribeUser()` function\n * in response to a user action signalling they would like to\n * subscribe to push messages from our app.\n */\nconst subscribeToPush = async (pubKey) => {\n    if (Notification.permission != \"granted\") {\n        throw new Error(\"Notification permission not granted\");\n    }\n    if (!(\"serviceWorker\" in navigator)) {\n        throw new Error(\"Service Worker not in Navigator\");\n    }\n    const reg = await navigator.serviceWorker.ready;\n    const sub = await reg?.pushManager.subscribe({\n        userVisibleOnly: true, // demanded by chrome\n        applicationServerKey: pubKey, // \"TODO :) VAPID Public Key (e.g. from Pod Server)\",\n    });\n    /*\n     * userVisibleOnly:\n     * A boolean indicating that the returned push subscription will only be used\n     * for messages whose effect is made visible to the user.\n     */\n    /*\n     * applicationServerKey:\n     * A Base64-encoded DOMString or ArrayBuffer containing an ECDSA P-256 public key\n     * that the push server will use to authenticate your application server\n     * Note: This parameter is required in some browsers like Chrome and Edge.\n     */\n    if (!sub) {\n        throw new Error(`Subscription failed: Sub == ${sub}`);\n    }\n    console.log(\"### PWA  \\t| Subscription created!\");\n    hasActivePush.value = true;\n    return sub.toJSON();\n};\nconst unsubscribeFromPush = async () => {\n    const sub = await _checkSubscription();\n    const isUnsubbed = await sub.unsubscribe();\n    console.log(\"### PWA  \\t| Subscription cancelled:\", isUnsubbed);\n    hasActivePush.value = false;\n    return sub.toJSON();\n};\nexport const useServiceWorkerNotifications = () => {\n    return {\n        askForNotificationPermission,\n        subscribeToPush,\n        unsubscribeFromPush,\n        hasActivePush,\n    };\n};\n","import { ref } from \"vue\";\nconst hasUpdatedAvailable = ref(false);\nlet registration;\n// Store the SW registration so we can send it a message\n// We use `updateExists` to control whatever alert, toast, dialog, etc we want to use\n// To alert the user there is an update they need to refresh for\nconst updateAvailable = (event) => {\n    registration = event.detail;\n    hasUpdatedAvailable.value = true;\n};\n// Called when the user accepts the update\nconst refreshApp = () => {\n    hasUpdatedAvailable.value = false;\n    // Make sure we only send a 'skip waiting' message if the SW is waiting\n    if (!registration || !registration.waiting)\n        return;\n    // send message to SW to skip the waiting and activate the new SW\n    registration.waiting.postMessage({ type: \"SKIP_WAITING\" });\n};\n// Listen for our custom event from the SW registration\nif ('addEventListener' in document) {\n    document.addEventListener(\"serviceWorkerUpdated\", updateAvailable, {\n        once: true,\n    });\n}\nlet isRefreshing = false;\n// this must not be in the service worker, since it will be updated ;-)\nif ('serviceWorker' in navigator) {\n    navigator.serviceWorker.addEventListener(\"controllerchange\", () => {\n        if (isRefreshing)\n            return;\n        isRefreshing = true;\n        window.location.reload();\n    });\n}\nexport const useServiceWorkerUpdate = () => {\n    return {\n        hasUpdatedAvailable,\n        refreshApp,\n    };\n};\n","/**\n * Concat the RDF namespace identified by the prefix used as function name\n * with the RDF thing identifier as function parameter,\n * e.g. FOAF(\"knows\") resovles to \"http://xmlns.com/foaf/0.1/knows\"\n * @param namespace uri of the namesapce\n * @returns function which takes a parameter of RDF thing identifier as string\n */\nfunction Namespace(namespace) {\n    return (thing) => thing ? namespace.concat(thing) : namespace;\n}\n// Namespaces as functions where their parameter is the RDF thing identifier => concat, e.g. FOAF(\"knows\") resolves to \"http://xmlns.com/foaf/0.1/knows\"\nexport const FOAF = Namespace(\"http://xmlns.com/foaf/0.1/\");\nexport const DCT = Namespace(\"http://purl.org/dc/terms/\");\nexport const RDF = Namespace(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\");\nexport const RDFS = Namespace(\"http://www.w3.org/2000/01/rdf-schema#\");\nexport const WDT = Namespace(\"http://www.wikidata.org/prop/direct/\");\nexport const WD = Namespace(\"http://www.wikidata.org/entity/\");\nexport const LDP = Namespace(\"http://www.w3.org/ns/ldp#\");\nexport const ACL = Namespace(\"http://www.w3.org/ns/auth/acl#\");\nexport const AUTH = Namespace(\"http://www.example.org/vocab/datev/auth#\");\nexport const AS = Namespace(\"https://www.w3.org/ns/activitystreams#\");\nexport const XSD = Namespace(\"http://www.w3.org/2001/XMLSchema#\");\nexport const ETHON = Namespace(\"http://ethon.consensys.net/\");\nexport const PDGR = Namespace(\"http://purl.org/pedigree#\");\nexport const LDCV = Namespace(\"http://people.aifb.kit.edu/co1683/2019/ld-chain/vocab#\");\nexport const WILD = Namespace(\"http://purl.org/wild/vocab#\");\nexport const VCARD = Namespace(\"http://www.w3.org/2006/vcard/ns#\");\nexport const GDPRP = Namespace(\"https://solid.ti.rw.fau.de/public/ns/gdpr-purposes#\");\nexport const PUSH = Namespace(\"https://purl.org/solid-web-push/vocab#\");\nexport const SEC = Namespace(\"https://w3id.org/security#\");\nexport const SPACE = Namespace(\"http://www.w3.org/ns/pim/space#\");\nexport const SVCS = Namespace(\"https://purl.org/solid-vc/credentialStatus#\");\nexport const CREDIT = Namespace(\"http://example.org/vocab/datev/credit#\");\nexport const SCHEMA = Namespace(\"http://schema.org/\");\nexport const INTEROP = Namespace(\"http://www.w3.org/ns/solid/interop#\");\nexport const SKOS = Namespace(\"http://www.w3.org/2004/02/skos/core#\");\nexport const ORG = Namespace(\"http://www.w3.org/ns/org#\");\nexport const MANDAT = Namespace(\"https://solid.aifb.kit.edu/vocab/mandat/\");\nexport const AD = Namespace(\"https://www.example.org/advertisement/\");\nexport const SHAPETREE = Namespace(\"https://solid.aifb.kit.edu/shapes/mandat/businessAssessment.tree#\");\n","import { BlankNode, Quad, Store, Writer, } from \"n3\";\nimport { RDF } from \"./namespaces\";\n/**\n * Generate the canonical string form of a node.\n * @param term n3 term\n * @return string\n */\nexport function canonicaliseTerm(term) {\n    switch (term.termType) {\n        case \"NamedNode\":\n            return `<${term.value}>`;\n        case \"BlankNode\":\n            return `_:${term.value}`;\n        case \"Literal\":\n            return `\"${term.value}\"^^<${term.datatypeString}>`;\n        default: // e.g. SerialisedTerm\n            return term.value;\n    }\n}\n/**\n * From an array, remove all occurences of values that occur more than twice, e.g. [1,2,3,3] => [1,2]\n * @param arr\n * @returns\n */\nconst _removeDoubles = (arr) => {\n    let arrVals = arr.map((term) => term.value);\n    arrVals = arrVals.filter((item) => arrVals.lastIndexOf(item) == arrVals.indexOf(item));\n    return arr.filter((term) => arrVals.includes(term.value));\n};\n/**\n * Find lists in an n3 store. Beginning by all rdf:nil, work upstream to retrieve all list items.\n * @param n3Store\n * @returns mapping { head of list : [items, correspondingQuads] }\n */\nconst _findLists = (n3Store) => {\n    const listMapping = {};\n    const endOfLists = n3Store.getQuads(null, RDF(\"rest\"), RDF(\"nil\"), null);\n    endOfLists.forEach((quad) => {\n        let items = [];\n        let quads = [];\n        let itemQuads = [];\n        let prevQuads = [quad];\n        let currentBN = \"\";\n        while (prevQuads.length !== 0) {\n            quads = prevQuads.concat(quads);\n            const currentQuad = prevQuads[0];\n            currentBN = currentQuad.subject.value;\n            // get upstream list items\n            itemQuads = n3Store.getQuads(currentQuad.subject, RDF(\"first\"), null, null);\n            quads = itemQuads.concat(quads);\n            items = itemQuads.map((quad) => quad.object).concat(items);\n            prevQuads = n3Store.getQuads(null, RDF(\"rest\"), currentQuad.subject, null);\n            // end when no prior item\n        }\n        listMapping[`${currentBN}`] = [items, quads];\n    });\n    return listMapping;\n};\nconst _serialiseList = (terms, listMapping, blankNodes, n3Store, n3Writer) => {\n    for (const [i, term] of terms.entries()) {\n        if (term.termType === \"BlankNode\") {\n            if (Object.keys(listMapping).includes(term.value)) { // list\n                const listTerms = listMapping[term.value][0];\n                console.log(listMapping);\n                const serialisation = ` ( ${_serialiseList(listTerms, listMapping, blankNodes, n3Store, n3Writer).map(canonicaliseTerm).join(\" \")} ) `;\n                terms[i] = { id: serialisation, value: serialisation };\n            }\n            else { // blank node\n                if (blankNodes.includes(term)) {\n                    terms[i] = _serialiseBlankNode(term, blankNodes, listMapping, n3Store, n3Writer);\n                }\n            }\n        }\n    }\n    return terms;\n};\nconst _serialiseBlankNode = (bn, blankNodes, listMapping, n3Store, n3Writer) => {\n    const bquads = n3Store.getQuads(bn, null, null, null);\n    const bquads_serial = bquads.map((bquad) => {\n        let obj = bquad.object;\n        if (obj.termType === \"BlankNode\") {\n            if (Object.keys(listMapping).includes(obj.value)) { // list\n                const listTerms = listMapping[obj.value][0];\n                const serialisation = ` ( ${_serialiseList(listTerms, listMapping, blankNodes, n3Store, n3Writer).map(canonicaliseTerm).join(\" \")} ) `;\n                obj = { id: serialisation, value: serialisation };\n            }\n            else // blank node\n             if (blankNodes.includes(bn)) {\n                obj = _serialiseBlankNode(obj, blankNodes, listMapping, n3Store, n3Writer);\n            }\n        }\n        return new Quad(bquad.subject, bquad.predicate, obj, bquad.graph);\n    });\n    const battr = [];\n    bquads_serial.forEach(bquad => {\n        battr.push({ predicate: bquad.predicate, object: bquad.object });\n    });\n    n3Store.removeQuads(bquads);\n    return n3Writer.blank(battr);\n};\n/**\n * Prints the turtle rdf format.\n *\n * @param n3Store\n * @param n3Prefixes\n * @param baseIRI\n * @returns string\n */\nexport const toTTL = (n3Store, n3Prefixes, baseIRI) => {\n    n3Store = new Store(n3Store.getQuads(null, null, null, null));\n    let result = \"\";\n    const n3Writer = new Writer({\n        baseIRI: baseIRI,\n        prefixes: n3Prefixes,\n    });\n    // find lists\n    const listMapping = _findLists(n3Store);\n    Object.entries(listMapping).forEach(entry => {\n        // uniquely referenced list head\n        if (n3Store.countQuads(null, null, new BlankNode(entry[0]), null) !== 1) {\n            delete listMapping[entry[0]]; // remove non unique list, or  dangling list from mapping\n        }\n    });\n    // find blank nodes in lists\n    const visitedBlankNodes = [];\n    Object.entries(listMapping).forEach((entry) => {\n        n3Store.removeQuads(entry[1][1]); // remove quads since we will do manual serialisation\n        entry[1][0].forEach((term) => {\n            if (term.termType === \"BlankNode\")\n                visitedBlankNodes.push(term);\n        });\n    });\n    // find uniquely referenced blank nodes\n    let blankNodes = [];\n    n3Store.getObjects(null, null, null).forEach((obj) => {\n        if (obj.termType == \"BlankNode\") {\n            // if that is already visited during list search, we have a double.\n            if (!visitedBlankNodes.map((term) => term.value).includes(obj.value)) { // if not, unique?\n                if (n3Store.countQuads(null, null, obj, null) == 1) { // unique!\n                    blankNodes.push(obj);\n                }\n            }\n            else { // visited, add for later easy removal of doubles\n                visitedBlankNodes.push(obj);\n            }\n        }\n    });\n    // array of uniquely referenced blank nodes in graph\n    blankNodes = blankNodes.concat(_removeDoubles(visitedBlankNodes));\n    // serialise lists\n    const serialisedLists = {};\n    Object.entries(listMapping).forEach(entry => {\n        // uniquely referenced list head\n        serialisedLists[entry[0]] = _serialiseList(entry[1][0], listMapping, blankNodes, n3Store, n3Writer); // create list serialisation\n    });\n    // serialise blank nodes\n    const serialisedBlankNodes = {};\n    blankNodes.forEach(bn => {\n        serialisedBlankNodes[bn.value] = _serialiseBlankNode(bn, blankNodes, listMapping, n3Store, n3Writer);\n    });\n    // // write\n    n3Store.getQuads(null, null, null, null).forEach((quad) => {\n        if (quad.object.value in serialisedLists) {\n            n3Writer.addQuad(quad.subject, quad.predicate, n3Writer.list(serialisedLists[quad.object.value]));\n        }\n        else if (quad.object.value in serialisedBlankNodes) {\n            n3Writer.addQuad(quad.subject, quad.predicate, serialisedBlankNodes[quad.object.value]);\n        }\n        else {\n            n3Writer.addQuad(quad);\n        }\n    });\n    // n3Writer.addQuads(n3Store.getQuads(null, null, null, null))\n    n3Writer.end((error, text) => (result = text));\n    // return `# Parsed from underlying RDF graph.\\n ${result}`;\n    return result;\n};\n/*\n  export function getListItems(n3Store, baseIRI) {\n    let node = n3Store\n      .getQuads(baseIRI, AS(\"items\"), null, null)\n      .map((quad) => quad.object)[0];\n\n    let result = [];\n\n    while (node.value !== RDF(\"nil\")) {\n      result.push(\n        n3Store\n          .getQuads(node, RDF(\"first\"), null, null)\n          .map((quad) => quad.object)\n      );\n      node = n3Store\n        .getQuads(node, RDF(\"rest\"), null, null)\n        .map((quad) => quad.object)[0];\n    }\n\n    return result.flat();\n  }\n\n  */\n","import axios from \"axios\";\n/**\n * When the client does not have a webid profile document, use this.\n *\n * @param registration_endpoint\n * @param redirect__uris\n * @returns\n */\nconst requestDynamicClientRegistration = async (registration_endpoint, redirect__uris) => {\n    // prepare dynamic client registration\n    const client_registration_request_body = {\n        redirect_uris: redirect__uris,\n        grant_types: [\"authorization_code\", \"refresh_token\"],\n        id_token_signed_response_alg: \"ES256\",\n        token_endpoint_auth_method: \"client_secret_basic\", // also works with value \"none\" if you do not provide \"client_secret\" on token request\n        application_type: \"web\",\n        subject_type: \"public\",\n    };\n    // register\n    return axios({\n        url: registration_endpoint,\n        method: \"post\",\n        data: client_registration_request_body,\n    });\n};\nexport { requestDynamicClientRegistration };\n","import axios from \"axios\";\nimport { exportJWK, SignJWT } from \"jose\";\n/**\n * Request an dpop-bound access token from a token endpoint\n * @param authorization_code\n * @param pkce_code_verifier\n * @param redirect_uri\n * @param client_id\n * @param client_secret\n * @param token_endpoint\n * @param key_pair\n * @returns\n */\nconst requestAccessToken = async (authorization_code, pkce_code_verifier, redirect_uri, client_id, client_secret, token_endpoint, key_pair) => {\n    // prepare public key to bind access token to\n    const jwk_public_key = await exportJWK(key_pair.publicKey);\n    jwk_public_key.alg = \"ES256\";\n    // sign the access token request DPoP token\n    const dpop = await new SignJWT({\n        htu: token_endpoint,\n        htm: \"POST\",\n    })\n        .setIssuedAt()\n        .setJti(window.crypto.randomUUID())\n        .setProtectedHeader({\n        alg: \"ES256\",\n        typ: \"dpop+jwt\",\n        jwk: jwk_public_key,\n    })\n        .sign(key_pair.privateKey);\n    return axios({\n        url: token_endpoint,\n        method: \"post\",\n        headers: {\n            dpop,\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n        data: new URLSearchParams({\n            grant_type: \"authorization_code\",\n            code: authorization_code,\n            code_verifier: pkce_code_verifier,\n            redirect_uri: redirect_uri,\n            client_id: client_id,\n            client_secret: client_secret,\n        }),\n    });\n};\nexport { requestAccessToken };\n","import axios from \"axios\";\nimport { requestDynamicClientRegistration } from \"./requestDynamicClientRegistration\";\nimport { generateKeyPair } from \"jose\";\nimport { requestAccessToken } from \"./requestAccessToken\";\n/**\n * Login with the idp, using dynamic client registration.\n * TODO generalise to use a provided client webid\n * TODO generalise to use provided client_id und client_secret\n *\n * @param idp\n * @param redirect_uri\n */\nconst redirectForLogin = async (idp, redirect_uri) => {\n    // RFC 9207 iss check: remember the identity provider (idp) / issuer (iss)\n    sessionStorage.setItem(\"idp\", idp);\n    // lookup openid configuration of idp\n    const openid_configuration = (await axios.get(`${idp}/.well-known/openid-configuration`)).data;\n    // remember token endpoint\n    sessionStorage.setItem(\"token_endpoint\", openid_configuration[\"token_endpoint\"]);\n    const registration_endpoint = openid_configuration[\"registration_endpoint\"];\n    // get client registration\n    const client_registration = (await requestDynamicClientRegistration(registration_endpoint, [\n        redirect_uri,\n    ])).data;\n    // remember client_id and client_secret\n    const client_id = client_registration[\"client_id\"];\n    sessionStorage.setItem(\"client_id\", client_id);\n    const client_secret = client_registration[\"client_secret\"];\n    sessionStorage.setItem(\"client_secret\", client_secret);\n    // RFC 7636 PKCE, remember code verifer\n    const { pkce_code_verifier, pkce_code_challenge } = await getPKCEcode();\n    sessionStorage.setItem(\"pkce_code_verifier\", pkce_code_verifier);\n    // RFC 6749 OAuth 2.0 - CSRF token\n    const csrf_token = window.crypto.randomUUID();\n    sessionStorage.setItem(\"csrf_token\", csrf_token);\n    // redirect to idp\n    const redirect_to_idp = openid_configuration[\"authorization_endpoint\"] +\n        `?response_type=code` +\n        `&redirect_uri=${encodeURIComponent(redirect_uri)}` +\n        `&scope=openid offline_access webid` +\n        `&client_id=${client_id}` +\n        `&code_challenge_method=S256` +\n        `&code_challenge=${pkce_code_challenge}` +\n        `&state=${csrf_token}` +\n        `&prompt=consent`; // this query parameter value MUST be present for CSS v7 to issue a refresh token (TODO open issue because prompting is the default behaviour but without this query param no refresh token is provided despite the \"remember this client\" box being checked)\n    window.location.href = redirect_to_idp;\n};\n/**\n * RFC 7636 PKCE\n * @returns PKCE code verifier and PKCE code challenge\n */\nconst getPKCEcode = async () => {\n    // create random string as PKCE code verifier\n    const pkce_code_verifier = window.crypto.randomUUID() + \"-\" + window.crypto.randomUUID();\n    // hash the verifier and base64URL encode as PKCE code challenge\n    const digest = new Uint8Array(await window.crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(pkce_code_verifier)));\n    const pkce_code_challenge = btoa(String.fromCharCode(...digest))\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=+$/, \"\");\n    return { pkce_code_verifier, pkce_code_challenge };\n};\n/**\n * On incoming redirect from OpenID provider (idp/iss),\n * URL contains authrization code, issuer (idp) and state (csrf token),\n * get an access token for the authrization code.\n */\nconst onIncomingRedirect = async () => {\n    const url = new URL(window.location.href);\n    // authorization code\n    const authorization_code = url.searchParams.get(\"code\");\n    if (authorization_code === null) {\n        return undefined;\n    }\n    // RFC 9207 issuer check\n    const idp = sessionStorage.getItem(\"idp\");\n    if (idp === null ||\n        url.searchParams.get(\"iss\") != idp + (idp.endsWith(\"/\") ? \"\" : \"/\")) {\n        throw new Error(\"RFC 9207 - iss != idp - \" + url.searchParams.get(\"iss\") + \" != \" + idp);\n    }\n    // RFC 6749 OAuth 2.0\n    if (url.searchParams.get(\"state\") != sessionStorage.getItem(\"csrf_token\")) {\n        throw new Error(\"RFC 6749 - state != csrf_token - \" +\n            url.searchParams.get(\"iss\") +\n            \" != \" +\n            sessionStorage.getItem(\"csrf_token\"));\n    }\n    // remove redirect query parameters from URL\n    url.searchParams.delete(\"iss\");\n    url.searchParams.delete(\"state\");\n    url.searchParams.delete(\"code\");\n    window.history.pushState({}, document.title, url.toString());\n    // prepare token request\n    const pkce_code_verifier = sessionStorage.getItem(\"pkce_code_verifier\");\n    if (pkce_code_verifier === null) {\n        throw new Error(\"Access Token Request preparation - Could not find in sessionStorage: pkce_code_verifier\");\n    }\n    const client_id = sessionStorage.getItem(\"client_id\");\n    if (client_id === null) {\n        throw new Error(\"Access Token Request preparation - Could not find in sessionStorage: client_id\");\n    }\n    const client_secret = sessionStorage.getItem(\"client_secret\");\n    if (client_secret === null) {\n        throw new Error(\"Access Token Request preparation - Could not find in sessionStorage: client_secret\");\n    }\n    const token_endpoint = sessionStorage.getItem(\"token_endpoint\");\n    if (token_endpoint === null) {\n        throw new Error(\"Access Token Request preparation - Could not find in sessionStorage: token_endpoint\");\n    }\n    // RFC 9449 DPoP\n    const key_pair = await generateKeyPair(\"ES256\");\n    // get access token\n    const token_response = (await requestAccessToken(authorization_code, pkce_code_verifier, url.toString(), client_id, client_secret, token_endpoint, key_pair)).data;\n    // TODO double check if I need to check token for ISS = IDP\n    // clean session storage\n    // sessionStorage.removeItem(\"idp\");\n    sessionStorage.removeItem(\"csrf_token\");\n    sessionStorage.removeItem(\"pkce_code_verifier\");\n    // sessionStorage.removeItem(\"client_id\");\n    // sessionStorage.removeItem(\"client_secret\");\n    // sessionStorage.removeItem(\"token_endpoint\");\n    // remember refresh_token for session\n    sessionStorage.setItem(\"refresh_token\", token_response[\"refresh_token\"]);\n    // return client login information\n    return {\n        ...token_response,\n        dpop_key_pair: key_pair,\n    };\n};\nexport { redirectForLogin, onIncomingRedirect };\n","import { SignJWT, exportJWK, generateKeyPair, } from \"jose\";\nimport axios from \"axios\";\nconst renewTokens = async () => {\n    const client_id = sessionStorage.getItem(\"client_id\");\n    const client_secret = sessionStorage.getItem(\"client_secret\");\n    const refresh_token = sessionStorage.getItem(\"refresh_token\");\n    const token_endpoint = sessionStorage.getItem(\"token_endpoint\");\n    if (!client_id || !client_secret || !refresh_token || !token_endpoint) {\n        // we can not restore the old session\n        throw new Error(\"Cannot renew tokens\");\n    }\n    // RFC 9449 DPoP\n    const key_pair = await generateKeyPair(\"ES256\");\n    const token_response = (await requestFreshTokens(refresh_token, client_id, client_secret, token_endpoint, key_pair)).data;\n    return {\n        ...token_response,\n        dpop_key_pair: key_pair,\n    };\n};\n/**\n * Request an dpop-bound access token from a token endpoint using a refresh token\n * @param authorization_code\n * @param pkce_code_verifier\n * @param redirect_uri\n * @param client_id\n * @param client_secret\n * @param token_endpoint\n * @param key_pair\n * @returns\n */\nconst requestFreshTokens = async (refresh_token, client_id, client_secret, token_endpoint, key_pair) => {\n    // prepare public key to bind access token to\n    const jwk_public_key = await exportJWK(key_pair.publicKey);\n    jwk_public_key.alg = \"ES256\";\n    // sign the access token request DPoP token\n    const dpop = await new SignJWT({\n        htu: token_endpoint,\n        htm: \"POST\",\n    })\n        .setIssuedAt()\n        .setJti(window.crypto.randomUUID())\n        .setProtectedHeader({\n        alg: \"ES256\",\n        typ: \"dpop+jwt\",\n        jwk: jwk_public_key,\n    })\n        .sign(key_pair.privateKey);\n    return axios({\n        url: token_endpoint,\n        method: \"post\",\n        headers: {\n            authorization: `Basic ${btoa(`${client_id}:${client_secret}`)}`,\n            dpop,\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n        data: new URLSearchParams({\n            grant_type: \"refresh_token\",\n            refresh_token: refresh_token,\n        }),\n    });\n};\nexport { renewTokens };\n","import { SignJWT, decodeJwt, exportJWK } from \"jose\";\nimport axios from \"axios\";\nimport { redirectForLogin, onIncomingRedirect, } from \"./AuthorizationCodeGrantFlow\";\nimport { renewTokens } from \"./RefreshTokenGrant\";\nexport class Session {\n    tokenInformation;\n    isActive_ = false;\n    webId_ = undefined;\n    login = redirectForLogin;\n    logout() {\n        this.tokenInformation = undefined;\n        this.isActive_ = false;\n        this.webId_ = undefined;\n        // clean session storage\n        sessionStorage.removeItem(\"idp\");\n        sessionStorage.removeItem(\"client_id\");\n        sessionStorage.removeItem(\"client_secret\");\n        sessionStorage.removeItem(\"token_endpoint\");\n        sessionStorage.removeItem(\"refresh_token\");\n    }\n    handleRedirectFromLogin() {\n        return onIncomingRedirect().then(async (sessionInfo) => {\n            if (!sessionInfo) {\n                // try refresh\n                sessionInfo = await renewTokens().catch((_) => {\n                    return undefined;\n                });\n            }\n            if (!sessionInfo) {\n                // still no session\n                return;\n            }\n            // we got a sessionInfo\n            this.tokenInformation = sessionInfo;\n            this.isActive_ = true;\n            this.webId_ = decodeJwt(this.tokenInformation.access_token)[\"webid\"];\n        });\n    }\n    async createSignedDPoPToken(payload) {\n        if (this.tokenInformation == undefined) {\n            throw new Error(\"Session not established.\");\n        }\n        const jwk_public_key = await exportJWK(this.tokenInformation.dpop_key_pair.publicKey);\n        return new SignJWT(payload)\n            .setIssuedAt()\n            .setJti(window.crypto.randomUUID())\n            .setProtectedHeader({\n            alg: \"ES256\",\n            typ: \"dpop+jwt\",\n            jwk: jwk_public_key,\n        })\n            .sign(this.tokenInformation.dpop_key_pair.privateKey);\n    }\n    /**\n     * Make axios requests.\n     * If session is established, authenticated requests are made.\n     *\n     * @param config the axios config to use (authorization header, dpop header will be overwritten in active session)\n     * @param dpopPayload optional, the payload of the dpop token to use (overwrites the default behaviour of `htu=config.url` and `htm=config.method`)\n     * @returns axios response\n     */\n    async authFetch(config, dpopPayload) {\n        // prepare authenticated call using a DPoP token (either provided payload, or default)\n        const headers = config.headers ? config.headers : {};\n        if (this.tokenInformation) {\n            const requestURL = new URL(config.url);\n            dpopPayload = dpopPayload\n                ? dpopPayload\n                : {\n                    htu: `${requestURL.protocol}//${requestURL.host}${requestURL.pathname}`,\n                    htm: config.method,\n                };\n            const dpop = await this.createSignedDPoPToken(dpopPayload);\n            headers[\"dpop\"] = dpop;\n            headers[\"authorization\"] = `DPoP ${this.tokenInformation.access_token}`;\n        }\n        config.headers = headers;\n        return axios(config);\n    }\n    get isActive() {\n        return this.isActive_;\n    }\n    get webId() {\n        return this.webId_;\n    }\n}\n","import { AxiosHeaders } from \"axios\";\nimport { Parser, Store } from \"n3\";\nimport { LDP } from \"./namespaces\";\nimport { Session } from \"./solid-oidc-client-browser/Session\";\n/**\n * #######################\n * ### BASIC REQUESTS  ###\n * #######################\n */\n/**\n *\n * @param response http response, e.g. from axiosFetch\n * @throws Error, if response is not ok\n * @returns the response, if response is ok\n */\nfunction _checkResponseStatus(response) {\n    if (response.status >= 400) {\n        throw new Error(`Action on \\`${response.request.url}\\` failed: \\`${response.status}\\` \\`${response.statusText}\\`.`);\n    }\n    return response;\n}\n/**\n *\n * @param uri the URI to strip from its fragment #\n * @return substring of the uri prior to fragment #\n */\nfunction _stripFragment(uri) {\n    if (typeof uri !== \"string\") {\n        return \"\";\n    }\n    const indexOfFragment = uri.indexOf(\"#\");\n    if (indexOfFragment !== -1) {\n        uri = uri.substring(0, indexOfFragment);\n    }\n    return uri;\n}\n/**\n *\n * @param uri `<http://ex.org>`\n * @returns `http://ex.org` without the parentheses\n */\nfunction _stripUriFromStartAndEndParentheses(uri) {\n    if (uri.startsWith(\"<\"))\n        uri = uri.substring(1, uri.length);\n    if (uri.endsWith(\">\"))\n        uri = uri.substring(0, uri.length - 1);\n    return uri;\n}\n/**\n * Parse text/turtle to N3.\n * @param text text/turtle\n * @param baseIRI string\n * @return Promise ParsedN3\n */\nexport async function parseToN3(text, baseIRI) {\n    const store = new Store();\n    const parser = new Parser({\n        baseIRI: _stripFragment(baseIRI),\n        blankNodePrefix: \"\",\n    }); // { blankNodePrefix: 'any' } does not have the effect I thought\n    return new Promise((resolve, reject) => {\n        // parser.parse is actually async but types don't tell you that.\n        parser.parse(text, (error, quad, prefixes) => {\n            if (error)\n                reject(error);\n            if (quad)\n                store.addQuad(quad);\n            else\n                resolve({ store, prefixes });\n        });\n    });\n}\n/**\n * Send a session.axiosFetch request: GET, uri, async requesting `text/turtle`\n *\n * @param uri: the URI of the text/turtle to get\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @param headers: OPTIONAL - headers to set manually (e.g. `Accept` or `baseIRI`), `content-type` is set by default to `text/turtle`.\n * @return Promise string of the response text/turtle\n */\nexport async function getResource(uri, session, headers) {\n    console.log(\"### SoLiD\\t| GET\\n\" + uri);\n    if (session === undefined)\n        session = new Session();\n    if (!headers)\n        headers = {};\n    headers[\"Accept\"] = headers[\"Accept\"]\n        ? headers[\"Accept\"]\n        : \"text/turtle,application/ld+json\";\n    return session\n        .authFetch({ url: uri, method: \"GET\", headers: headers })\n        .then(_checkResponseStatus);\n}\n/**\n * Send a session.axiosFetch request: POST, uri, async providing `text/turtle`\n * providing `text/turtle` and baseURI header, accepting `text/turtle`\n *\n * @param uri: the URI of the server (the text/turtle to post to)\n * @param body: OPTIONAL - the text/turtle to provide\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @param headers: OPTIONAL - headers to set manually (e.g. `Accept` or `baseIRI`), `content-type` is set by default to `text/turtle`.\n * @return Promise of the response\n */\nexport async function postResource(uri, body, session, headers) {\n    if (session === undefined)\n        session = new Session();\n    if (!headers)\n        headers = {};\n    headers[\"Content-type\"] = headers[\"Content-type\"]\n        ? headers[\"Content-type\"]\n        : \"text/turtle\";\n    return session\n        .authFetch({\n        url: uri,\n        method: \"POST\",\n        headers: headers,\n        data: body,\n    })\n        .then(_checkResponseStatus);\n}\n/**\n * Send a session.axiosFetch request: POST, location uri, container name, async .\n * This will generate a new URI at which the resource will be available.\n * The response's `Location` header will contain the URL of the created resource.\n *\n * @param uri: the URI of the resrouce to post to / to be located at\n * @param body: the body of the resource to create\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @return Promise Response\n */\nexport async function createResource(locationURI, body, session, headers) {\n    console.log(\"### SoLiD\\t| CREATE RESOURCE AT\\n\" + locationURI);\n    if (!headers)\n        headers = {};\n    headers[\"Content-type\"] = headers[\"Content-type\"]\n        ? headers[\"Content-type\"]\n        : \"text/turtle\";\n    headers[\"Link\"] = `<${LDP(\"Resource\")}>; rel=\"type\"`;\n    return postResource(locationURI, body, session, headers);\n}\n/**\n * Send a session.axiosFetch request: POST, location uri, resource name, async .\n * If the container already exists, an additional one with a prefix will be created.\n * The response's `Location` header will contain the URL of the created resource.\n *\n * @param uri: the URI of the container to post to\n * @param name: the name of the container\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @return Promise Response (location header not included (i think) since you know the name and folder)\n */\nexport async function createContainer(locationURI, name, session) {\n    console.log(\"### SoLiD\\t| CREATE CONTAINER\\n\" + locationURI + name + \"/\");\n    const body = undefined;\n    return postResource(locationURI, body, session, {\n        Link: `<${LDP(\"BasicContainer\")}>; rel=\"type\"`,\n        Slug: name,\n    });\n}\n/**\n * Get the Location header of a newly created resource.\n * @param resp string location header\n */\nexport function getLocationHeader(resp) {\n    if (!(resp.headers instanceof AxiosHeaders && resp.headers.has(\"Location\"))) {\n        throw new Error(`Location Header at \\`${resp.request.url}\\` not set.`);\n    }\n    let loc = resp.headers.get(\"Location\");\n    if (!loc) {\n        throw new Error(`Could not get Location Header at \\`${resp.request.url}\\`.`);\n    }\n    loc = loc.toString();\n    if (!loc.startsWith(\"http://\") && !loc.startsWith(\"https://\")) {\n        loc = new URL(resp.request.url).origin + loc;\n    }\n    return loc;\n}\n/**\n * Shortcut to get the items in a container.\n *\n * @param uri The container's URI to get the items from\n * @param session\n * @returns string URIs of the items in the container\n */\nexport async function getContainerItems(uri, session) {\n    console.log(\"### SoLiD\\t| GET CONTAINER ITEMS\\n\" + uri);\n    return getResource(uri, session)\n        .then((resp) => resp.data)\n        .then((txt) => parseToN3(txt, uri))\n        .then((parsedN3) => parsedN3.store)\n        .then((store) => store.getObjects(uri, LDP(\"contains\"), null).map((obj) => obj.value));\n}\n/**\n * Send a session.axiosFetch request: PUT, uri, async providing `text/turtle`\n *\n * @param uri: the URI of the text/turtle to be put\n * @param body: the text/turtle to provide\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @return Promise string  of the created URI from the response `Location` header\n */\nexport async function putResource(uri, body, session, headers) {\n    console.log(\"### SoLiD\\t| PUT\\n\" + uri);\n    if (session === undefined)\n        session = new Session();\n    if (!headers)\n        headers = {};\n    headers[\"Content-type\"] = headers[\"Content-type\"]\n        ? headers[\"Content-type\"]\n        : \"text/turtle\";\n    headers[\"Link\"] = `<${LDP(\"Resource\")}>; rel=\"type\"`;\n    return session\n        .authFetch({\n        url: uri,\n        method: \"PUT\",\n        headers: headers,\n        data: body,\n    })\n        .then(_checkResponseStatus);\n}\n/**\n * Send a session.axiosFetch request: PATCH, uri, async providing `text/n3`\n *\n * @param uri: the URI of the text/n3 to be patch\n * @param body: the text/turtle to provide\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @return Promise string  of the created URI from the response `Location` header\n */\nexport async function patchResource(uri, body, session) {\n    console.log(\"### SoLiD\\t| PATCH\\n\" + uri);\n    if (session === undefined)\n        session = new Session();\n    return session\n        .authFetch({\n        url: uri,\n        method: \"PATCH\",\n        headers: { \"Content-Type\": \"text/n3\" },\n        data: body,\n    })\n        .then(_checkResponseStatus);\n}\n/**\n * Send a session.axiosFetch request: DELETE, uri, async\n *\n * @param uri: the URI of the text/turtle to delete\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @return true if http request successfull with status 204\n */\nexport async function deleteResource(uri, session) {\n    console.log(\"### SoLiD\\t| DELETE\\n\" + uri);\n    if (session === undefined)\n        session = new Session();\n    return session\n        .authFetch({\n        url: uri,\n        method: \"DELETE\",\n    })\n        .then(_checkResponseStatus)\n        .then(() => true);\n}\n/**\n * ####################\n * ## Access Control ##\n * ####################\n */\n/**\n * `http://ex.org/test.txt` > `http://ex.org/` and `http://ex.org/test/` > `http://ex.org/test/`\n * @param uri the resource\n * @returns folder the resource is in; if the resource is a folder, the folder uri itself is returned\n */\nfunction _getSameLocationAs(uri) {\n    return uri.substring(0, uri.lastIndexOf(\"/\") + 1);\n}\n/**\n * `http://ex.org/test.txt` > `http://ex.org/` and `http://ex.org/test/` > `http://ex.org/`\n * @param uri the resource\n * @returns the URI of the parent resource, i.e. the folder where the resource lives\n */\nfunction _getParentUri(uri) {\n    let parent;\n    if (!uri.endsWith(\"/\"))\n        // uri is resource\n        parent = _getSameLocationAs(uri);\n    else\n        parent = uri\n            // get parent folder\n            .substring(0, uri.length - 1)\n            .substring(0, uri.lastIndexOf(\"/\"));\n    if (parent == \"http://\" || parent == \"https://\")\n        throw new Error(`Parent not found: Reached root folder at \\`${uri}\\`.`); // reached the top\n    return parent;\n}\n/**\n * Parses Header \"Link\", e.g. <.acl>; rel=\"acl\", <.meta>; rel=\"describedBy\", <http://www.w3.org/ns/ldp#Container>; rel=\"type\", <http://www.w3.org/ns/ldp#BasicContainer>; rel=\"type\"\n *\n * @param txt string of the Link Header#\n * @returns the object parsed\n */\nfunction _parseLinkHeader(txt) {\n    const parsedObj = {};\n    const propArray = txt.split(\",\").map((obj) => obj.split(\";\"));\n    for (const prop of propArray) {\n        if (parsedObj[prop[1].trim().split('\"')[1]] === undefined) {\n            // first element to have this prop type\n            parsedObj[prop[1].trim().split('\"')[1]] = prop[0].trim();\n        }\n        else {\n            // this prop type is already set\n            const propArray = new Array(parsedObj[prop[1].trim().split('\"')[1]]).flat();\n            propArray.push(prop[0].trim());\n            parsedObj[prop[1].trim().split('\"')[1]] = propArray;\n        }\n    }\n    return parsedObj;\n}\n/**\n * Send a session.axiosFetch request: HEAD, uri, header `Link` as json obj\n *\n * @param uri: the URI of the text/turtle to get the access control file for\n * @param session: OPTIONAL - session.axiosFetch function to use, e.g. session.authFetch of a solid session\n * @return Json object of the Link header\n */\nexport async function getLinkHeader(uri, session) {\n    console.log(\"### SoLiD\\t| HEAD\\n\" + uri);\n    if (session === undefined)\n        session = new Session();\n    return session\n        .authFetch({ url: uri, method: \"HEAD\" })\n        .then(_checkResponseStatus)\n        .then((resp) => {\n        if (!(resp.headers instanceof AxiosHeaders && resp.headers.has(\"Link\"))) {\n            throw new Error(`Link Header at \\`${resp.request.url}\\` not set.`);\n        }\n        const linkHeader = resp.headers.get(\"Link\");\n        if (linkHeader == null) {\n            throw new Error(`Could not get Link Header at \\`${resp.request.url}\\`.`);\n        }\n        else {\n            return linkHeader.toString();\n        }\n    }) // e.g. <.acl>; rel=\"acl\", <.meta>; rel=\"describedBy\", <http://www.w3.org/ns/ldp#Container>; rel=\"type\", <http://www.w3.org/ns/ldp#BasicContainer>; rel=\"type\"\n        .then(_parseLinkHeader);\n}\nexport async function getAclResourceUri(uri, session) {\n    console.log(\"### SoLiD\\t| ACL\\n\" + uri);\n    if (session === undefined)\n        session = new Session();\n    return getLinkHeader(uri, session)\n        .then((lnk) => _stripUriFromStartAndEndParentheses(lnk.acl))\n        .then((acl) => {\n        if (acl.startsWith(\"http://\") || acl.startsWith(\"https://\")) {\n            return acl;\n        }\n        return _getSameLocationAs(uri) + acl;\n    });\n}\n","import { INTEROP } from \"./namespaces\";\nimport { Session } from \"./solid-oidc-client-browser/Session\";\nimport { createResource, getResource, parseToN3 } from \"./solidRequests\";\nexport async function createResourceInAnyRegistrationOfShape(webId, shapeTreeUri, resourceBody, session) {\n    if (session === undefined)\n        session = new Session();\n    const offerContainerUris = (await getDataRegistrationContainers(webId, shapeTreeUri, session))[0];\n    return await createResource(offerContainerUris, resourceBody, session);\n}\nexport async function getDataRegistrationContainers(webId, shapeTreeUri, session) {\n    if (session === undefined)\n        session = new Session();\n    const registrySetUris = await getRegistrySet(webId, session);\n    const dataRegistryUris = [];\n    for (const registrySetUri of registrySetUris) {\n        dataRegistryUris.push(...(await getDataRegistry(registrySetUri, session)));\n    }\n    const dataRegistrationUris = [];\n    for (const dataRegistryUri of dataRegistryUris) {\n        dataRegistrationUris.push(...(await getDataRegistrations(dataRegistryUri, session)));\n    }\n    const dataRegistrationsOfShapeUris = [];\n    for (const dataRegistrationUri of dataRegistrationUris) {\n        const hasMatchingShape = await filterDataRegistrationUrisByShapeTreeUri(dataRegistrationUri, shapeTreeUri, session);\n        if (hasMatchingShape) {\n            dataRegistrationsOfShapeUris.push(dataRegistrationUri);\n        }\n    }\n    return dataRegistrationsOfShapeUris;\n}\nfunction getRegistrySet(webId, session) {\n    if (session === undefined)\n        session = new Session();\n    return getResourceAsStore(webId, session).then((store) => store\n        .getObjects(null, INTEROP(\"hasRegistrySet\"), null)\n        .map((term) => term.value));\n}\nfunction getDataRegistry(registrySetUri, session) {\n    if (session === undefined)\n        session = new Session();\n    return getResourceAsStore(registrySetUri, session).then((store) => store\n        .getObjects(null, INTEROP(\"hasDataRegistry\"), null)\n        .map((term) => term.value));\n}\nasync function getDataRegistrations(dataRegistryUri, session) {\n    if (session === undefined)\n        session = new Session();\n    return getResourceAsStore(dataRegistryUri, session).then((store) => store\n        .getObjects(null, INTEROP(\"hasDataRegistration\"), null)\n        .map((term) => term.value));\n}\nfunction getRegisteredShapeTree(dataRegistrationUri, session) {\n    if (session === undefined)\n        session = new Session();\n    return getResourceAsStore(dataRegistrationUri, session).then((store) => store.getObjects(null, INTEROP(\"registeredShapeTree\"), null)[0].value);\n}\nasync function filterDataRegistrationUrisByShapeTreeUri(dataRegistrationUri, shapeTreeUri, session) {\n    if (session === undefined)\n        session = new Session();\n    const dataRegistrationShapeTree = await getRegisteredShapeTree(dataRegistrationUri, session);\n    return dataRegistrationShapeTree === shapeTreeUri;\n}\nfunction getResourceAsStore(uri, session) {\n    if (session === undefined)\n        session = new Session();\n    return getResource(uri, session)\n        .then((resp) => resp.data)\n        .then((txt) => parseToN3(txt, uri))\n        .then((parsedN3) => parsedN3.store);\n}\n","export * from './src/n3Extensions';\nexport * from './src/namespaces';\nexport * from './src/solidRequests';\nexport * from './src/interopRequest';\nexport * from './src/solid-oidc-client-browser/Session';\n","import { Session } from \"hackathon-demo/libs/solid\";\nexport class RdpCapableSession extends Session {\n    rdp_;\n    constructor(rdp) {\n        super();\n        if (rdp !== \"\") {\n            this.updateSessionWithRDP(rdp);\n        }\n    }\n    async authFetch(config, dpopPayload) {\n        const requestedURL = new URL(config.url);\n        if (this.rdp_ !== undefined && this.rdp_ !== \"\") {\n            const requestURL = new URL(config.url);\n            requestURL.searchParams.set(\"host\", requestURL.host);\n            requestURL.host = new URL(this.rdp_).host;\n            config.url = requestURL.toString();\n        }\n        if (!dpopPayload) {\n            dpopPayload = {\n                htu: `${requestedURL.protocol}//${requestedURL.host}${requestedURL.pathname}`, // ! adjust to `${requestURL.protocol}//${requestURL.host}${requestURL.pathname}`\n                htm: config.method,\n                // ! ptu: requestedURL.toString(),\n            };\n        }\n        return super.authFetch(config, dpopPayload);\n    }\n    updateSessionWithRDP(rdp) {\n        this.rdp_ = rdp;\n    }\n    get rdp() {\n        return this.rdp_;\n    }\n}\n","import { reactive } from \"vue\";\nimport { RdpCapableSession } from \"./rdpCapableSession\";\nconst session = reactive(new RdpCapableSession(\"\"));\nasync function restoreSession() {\n    await session.handleRedirectFromLogin();\n}\n/**\n * Auto-re-login / and handle redirect after login\n *\n * Use in App.vue like this\n * ```ts\n    // plain (without any routing framework)\n    restoreSession()\n    // but if you use a router, make sure it is ready\n    router.isReady().then(restoreSession)\n   ```\n */\nexport const useSolidSession = () => {\n    return {\n        session,\n        restoreSession,\n    };\n};\n","import { ref, watch } from \"vue\";\nimport { useSolidSession } from \"./useSolidSession\";\nimport { getResource, INTEROP, LDP, parseToN3, SPACE, VCARD, ORG, MANDAT, } from \"hackathon-demo/libs/solid\";\nimport { Store } from \"n3\";\nconst { session } = useSolidSession();\nconst name = ref(\"\");\nconst img = ref(\"\");\nconst inbox = ref(\"\");\nconst storage = ref(\"\");\nconst authAgent = ref(\"\");\nconst accessInbox = ref(\"\");\nconst memberOf = ref(\"\");\nconst hasOrgRDP = ref(\"\");\nwatch(() => session.webId, async () => {\n    const webId = session.webId;\n    let store = new Store();\n    if (session.webId !== undefined) {\n        store = await getResource(webId)\n            .then((resp) => resp.data)\n            .then((respText) => parseToN3(respText, webId))\n            .then((parsedN3) => parsedN3.store);\n    }\n    let query = store.getObjects(webId, VCARD(\"hasPhoto\"), null);\n    img.value = query.length > 0 ? query[0].value : \"\";\n    query = store.getObjects(webId, VCARD(\"fn\"), null);\n    name.value = query.length > 0 ? query[0].value : \"\";\n    query = store.getObjects(webId, LDP(\"inbox\"), null);\n    inbox.value = query.length > 0 ? query[0].value : \"\";\n    query = store.getObjects(webId, SPACE(\"storage\"), null);\n    storage.value = query.length > 0 ? query[0].value : \"\";\n    query = store.getObjects(webId, INTEROP(\"hasAuthorizationAgent\"), null);\n    authAgent.value = query.length > 0 ? query[0].value : \"\";\n    query = store.getObjects(webId, INTEROP(\"hasAccessInbox\"), null);\n    accessInbox.value = query.length > 0 ? query[0].value : \"\";\n    query = store.getObjects(webId, ORG(\"memberOf\"), null);\n    const uncheckedMemberOf = query.length > 0 ? query[0].value : \"\";\n    if (uncheckedMemberOf !== \"\") {\n        let storeOrg = new Store();\n        storeOrg = await getResource(uncheckedMemberOf)\n            .then((resp) => resp.data)\n            .then((respText) => parseToN3(respText, uncheckedMemberOf))\n            .then((parsedN3) => parsedN3.store);\n        const isMember = storeOrg.getQuads(uncheckedMemberOf, ORG(\"hasMember\"), webId, null)\n            .length > 0;\n        if (isMember) {\n            memberOf.value = uncheckedMemberOf;\n            query = storeOrg.getObjects(uncheckedMemberOf, MANDAT(\"hasRightsDelegationProxy\"), null);\n            hasOrgRDP.value = query.length > 0 ? query[0].value : \"\";\n            session.updateSessionWithRDP(hasOrgRDP.value);\n            // and also overwrite fields from org profile\n            query = storeOrg.getObjects(memberOf.value, VCARD(\"fn\"), null);\n            name.value += ` (Org: ${query.length > 0 ? query[0].value : \"N/A\"})`;\n            query = storeOrg.getObjects(memberOf.value, LDP(\"inbox\"), null);\n            inbox.value = query.length > 0 ? query[0].value : \"\";\n            query = storeOrg.getObjects(memberOf.value, SPACE(\"storage\"), null);\n            storage.value = query.length > 0 ? query[0].value : \"\";\n            query = storeOrg.getObjects(memberOf.value, INTEROP(\"hasAuthorizationAgent\"), null);\n            authAgent.value = query.length > 0 ? query[0].value : \"\";\n            query = storeOrg.getObjects(memberOf.value, INTEROP(\"hasAccessInbox\"), null);\n            accessInbox.value = query.length > 0 ? query[0].value : \"\";\n        }\n    }\n});\nexport const useSolidProfile = () => {\n    return {\n        name,\n        img,\n        inbox,\n        storage,\n        authAgent,\n        accessInbox,\n        memberOf,\n        hasOrgRDP,\n    };\n};\n","import { AS, createResource, getResource, LDP, parseToN3, PUSH, RDF } from \"hackathon-demo/libs/solid\";\nimport { useServiceWorkerNotifications } from \"./useServiceWorkerNotifications\";\nimport { useSolidSession } from \"./useSolidSession\";\nconst { unsubscribeFromPush, subscribeToPush } = useServiceWorkerNotifications();\nconst { session } = useSolidSession();\n// hardcoding for my demo\nconst solidWebPushProfile = \"https://solid.aifb.kit.edu/web-push/service\";\n// usually this should expect the resource to sub to, then check their .meta and so on...\nconst _getSolidWebPushDetails = async () => {\n    const { store } = await getResource(solidWebPushProfile)\n        .then((resp) => resp.data)\n        .then((txt) => parseToN3(txt, solidWebPushProfile));\n    const service = store.getSubjects(AS(\"Service\"), null, null)[0];\n    const inbox = store.getObjects(service, LDP(\"inbox\"), null)[0].value;\n    const vapidPublicKey = store.getObjects(service, PUSH(\"vapidPublicKey\"), null)[0].value;\n    return { inbox, vapidPublicKey };\n};\nconst _createSubscriptionOnResource = (uri, details) => {\n    return `\n@prefix rdf: <${RDF()}> .\n@prefix as: <${AS()}> .\n@prefix push: <${PUSH()}> .\n<#sub> a as:Follow;\n    as:actor <${session.webId}>;\n    as:object <${uri}>;\n    push:endpoint \"${details.endpoint}\";\n    # expirationTime: null # undefined\n    push:keys [\n            push:auth \"${details.keys.auth}\";\n\t\t\t      push:p256dh \"${details.keys.p256dh}\"\n\t\t    ].    \n    `;\n};\nconst _createUnsubscriptionFromResource = (uri, details) => {\n    return `\n@prefix rdf: <${RDF()}> .\n@prefix as: <${AS()}> .\n@prefix push: <${PUSH()}> .\n<#unsub> a as:Undo;\n    as:actor <${session.webId}>;\n    as:object [\n            a as:Follow;\n            as:actor <${session.webId}>;\n            as:object <${uri}>;\n            push:endpoint \"${details.endpoint}\";\n            # expirationTime: null # undefined\n            push:keys [\n                    push:auth \"${details.keys.auth}\";\n\t\t        \t      push:p256dh \"${details.keys.p256dh}\"\n\t\t                  ]\n              ].    \n    `;\n};\nconst subscribeForResource = async (uri) => {\n    const { inbox, vapidPublicKey } = await _getSolidWebPushDetails();\n    const sub = await subscribeToPush(vapidPublicKey);\n    const solidWebPushSub = _createSubscriptionOnResource(uri, sub);\n    console.log(solidWebPushSub);\n    return createResource(inbox, solidWebPushSub, session);\n};\nconst unsubscribeFromResource = async (uri) => {\n    const { inbox } = await _getSolidWebPushDetails();\n    const sub_old = await unsubscribeFromPush();\n    const solidWebPushUnSub = _createUnsubscriptionFromResource(uri, sub_old);\n    console.log(solidWebPushUnSub);\n    return createResource(inbox, solidWebPushUnSub, session);\n};\nexport const useSolidWebPush = () => {\n    return {\n        subscribeForResource,\n        unsubscribeFromResource\n    };\n};\n","import { useSolidProfile } from \"./useSolidProfile\";\nimport { useSolidSession } from \"./useSolidSession\";\nimport { computed } from \"vue\";\nexport const useIsLoggedIn = () => {\n    const { session } = useSolidSession();\n    const { memberOf } = useSolidProfile();\n    const isLoggedIn = computed(() => {\n        return (!!((session.webId && !memberOf) || (session.webId && memberOf && session.rdp)));\n    });\n    return { isLoggedIn };\n};\n","export * from './src/useCache';\nexport * from './src/useServiceWorkerNotifications';\nexport * from './src/useServiceWorkerUpdate';\n// export * from './src/useSolidInbox';\nexport * from './src/useSolidProfile';\nexport * from './src/useSolidSession';\n// export * from './src/useSolidWallet';\nexport * from './src/useSolidWebPush';\nexport * from \"./src/webPushSubscription\";\nexport * from \"./src/useIsLoggedIn\";\nexport { RdpCapableSession } from \"./src/rdpCapableSession\";\n","export { default } from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/ts-loader/index.js??clonedRuleSet-83.use[1]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./LogoutButton.vue?vue&type=script&lang=ts\"; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/ts-loader/index.js??clonedRuleSet-83.use[1]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./LogoutButton.vue?vue&type=script&lang=ts\"","import { render } from \"./LogoutButton.vue?vue&type=template&id=79d8ba55&ts=true\"\nimport script from \"./LogoutButton.vue?vue&type=script&lang=ts\"\nexport * from \"./LogoutButton.vue?vue&type=script&lang=ts\"\n\nimport exportComponent from \"../../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import './setPublicPath'\nimport mod from '~entry'\nexport default mod\nexport * from '~entry'\n"],"names":["session"],"sourceRoot":""}